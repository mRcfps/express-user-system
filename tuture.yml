name: Express 搭建完整的后台用户系统
id: 367d98ae71986bc82e1d5e6a185242b0
steps:
  - name: 初始化项目
    commit: 73879db
    diff:
      - file: .gitignore
      - file: package-lock.json
      - file: package.json
        display: true
        explain:
          pre: >-
            然后运行 `npm init`，回答完一系列问题即可生成 package.json 文件（如果你懒得回答问题的话可以加上 `-y`
            选项）。然后安装 express 和 morgan（日志中间件）。


            ```bash

            $ npm install express morgan

            ```


            你也可以直接复制下面 package.json 的内容，然后执行 `npm install`。
          post: 这里我们将 `private` 字段设置为 `true`，是为了避免意外发布此项目。
    explain:
      pre: >
        创建一个目录用于开发此项目：


        ```bash

        $ mkdir express-user-system && cd express-user-system

        ```



        >
        如果想要查看最终的代码，你可以把这个[仓库](https://github.com/mRcfps/express-user-system.git)
        clone 下来，然后切换到 `finish-1` 分支：

        > ```bash

        > $ git clone https://github.com/mRcfps/express-user-system.git

        > $ cd express-user-system

        > $ git checkout finish-1

        > ```
  - name: 编写最简单的服务器
    commit: dcc0730
    diff:
      - file: .gitignore
      - file: package.json
        display: true
        explain:
          pre: 接下来在 package.json 中添加 npm `start` 脚本：
      - file: app.js
        display: true
        explain:
          pre: 创建 app.js 如下：
          post: >-
            首先我们在第 4 行初始化了一个 express app，然后在第 6 行注册了一个中间件 `morgan()`，在第 8
            行注册了一个路由中间件。express 将会按照从上到下的顺序依次执行中间件。


            最后在第 12 行，我们让 `app` 监听 3000 端口。
    explain:
      pre: 这里我们用 express 编写一个最简单的 web 服务器。
      post: >-
        运行 `npm start`，在浏览器中访问
        [localhost:3000](http://localhost:3000)，可以看到我们的服务器返回了“主页”两字，并且由于 morgan
        中间件的作用，我们可以看到访问日志记录：


        ```

        GET / 200 2.791 ms - 6

        ```
  - name: 实现用户模型
    commit: d2ab91c
    diff:
      - file: package.json
        display: true
        explain:
          pre: >-
            我们首先要安装两个包，mongoose 和 argon2：


            ```bash

            $ npm install mongoose argon2

            ```


            **mongoose**


            MongoDB 官方推出了数据库驱动库 [mongodb](https://www.npmjs.com/package/mongodb)
            ，但这里我们将使用 [mongoose](https://www.npmjs.com/package/mongoose)
            来操纵数据库，因为 mongoose 作为 ODM（Object Document
            Mapping，对象文档映射），在操纵文档型数据库时具有更友好的 API，也就意味着更高的开发效率。


            **argon2**


            在数据库中存储用户密码时必须要先**加密**（明文存储密码发生的悲剧历历在目），通常比较流行的加密算法是 MD5 或是
            Bcrypt。但这里我们要使用的是密码加密大赛的冠军 —— [argon2](https://www.argon2.com/)。
      - file: models/User.js
        display: true
        explain:
          pre: 然后我们创建 models/User.js 文件。通常把所有 model 模块放到一个 models 目录里面是一个很好的习惯。
          post: >-
            需要关注两个地方：


            - 第 9 行，我们在 `userSchema` 的定义中，将 `schemaOptions` 的 `timestamps` 字段设置为
            `true`，这样 Mongo 就会自动为我们的模型添加 `updatedAt`（上次更新时间）和 `createdAt`
            （创建时间）两个字段

            - 第 12 行，我们为模型增加了 pre-save 钩子，这样在每次保存一个 User 模型之前，明文密码就会被加密后存储。


            > 注意！在写 mongoose 钩子函数时**不能使用箭头函数**！因为钩子函数依赖 `this` 上下文环境.
      - file: package-lock.json
      - file: tuture.yml
    explain:
      pre: >-
        接下来我们就要连接数据库了，我们将使用 Node 社区最受欢迎的
        [MongoDB](https://www.mongodb.com/)。凭借其灵活性、高可用性和高扩展性（吹 Mongo
        的文章太多了，自己去搜搜看吧），MongoDB 几乎成为了各应用场景的首选。


        如果你没有安装
        MongoDB，可以访问[这里](https://docs.mongodb.com/manual/administration/install-community/)了解一下如何安装。安装完成后，运行下面的命令打开
        Mongo 数据库：


        ```bash

        $ mongod

        ```


        如果没有出现任何错误，就说明已经安装成功了！
      post: >-
        我们在 Node 交互式执行环境（REPL）中测试一下我们刚刚写的模型：


        ```javascript

        $ node

        > const mongoose = require('mongoose');

        undefined

        > // 连接数据库

        > mongoose.connect('mongodb://localhost:27017/test');

        Promise {
          <pending>,
          domain:
           Domain {
             domain: null,
             _events: { error: [Function: debugDomainError] },
             _eventsCount: 1,
             _maxListeners: undefined,
             members: [] } }
        > const User = require('./models/User')

        undefined

        > // 创建一个用户模型

        > const testUser = new User({ username: 'test', password: 'test' });

        undefined

        > // 保存用户模型

        > testUser.save().then(user => console.log(user));

        Promise {
          <pending>,
          domain:
           Domain {
             domain: null,
             _events: { error: [Function: debugDomainError] },
             _eventsCount: 1,
             _maxListeners: undefined,
             members: [] } }
        > { _id: 5b8e4baa6e617d2d82d3e54b,
          username: 'test',
          password: '$argon2i$v=19$m=4096,t=3,p=1$gMkRF7LR6KGpVv3ys95urw$KUK6Lsnt8xvK6D3C+l//VrHz89Zz91wqt+VotIpG3ec',
          createdAt: 2018-09-04T09:09:03.454Z,
          updatedAt: 2018-09-04T09:09:03.454Z,
          __v: 0 }
        ```


        最后的输出结果中，我们可以清晰地看到用户模型是以怎样的形式存储在数据库中——`_id` 是 MongoDB 为 `testUser`
        模型生成的唯一标识符，`password` 存储了加密后的密码，以及自动生成的 `createdAt` 和 `updatedAt` 字段。


        干得不错！接下来让我们把服务器中接入数据库吧！
  - name: 实现注册端口
    commit: fd6375d
    diff:
      - file: package.json
        display: true
        explain:
          pre: |-
            首先我们需要处理 POST 请求体，这将由 body-parser 中间件来负责：

            ```bash
            $ npm install body-parser
            ```
      - file: app.js
        display: true
        explain:
          pre: 然后在 app.js 中添加连接数据库、注册 `bodyParser` 中间件、添加 signup 路由的代码：
          post: >-
            数据库连接部分的代码在之前 REPL 中测试过，因此不再详述。


            `bodyParser` 的两个中间件分别负责处理 JSON 和表单数据的解析，解析之后的数据我们可以通过 `req.body`
            来访问。例如对于下面的 JSON 数据：


            ```json

            {
              "username": "test",
              "password": "test"
            }

            ```


            我们可以分别通过 `req.body.username` 和 `req.body.password` 来获取用户名和密码。


            至于 signup 路由逻辑的实现，这里我们使用了 Promise
            的链式调用技巧（如果你不太了解的话，可以阅读一下[这篇文章](https://segmentfault.com/a/1190000007598894)）来顺序执行各个操作：


            1.
            从数据库中查询此用户名是否有对应的用户，可以在[这里](https://mongoosejs.com/docs/queries.html)查看所有的查询方法。

            2. 如果查询到用户，则终止 Promise 链的执行，否则就创建新的用户模型并保存至数据库

            3. 保存至数据库成功，返回 201（Created）和相应信息


            我们在 Promise 链的最后使用 `catch` 来捕获所有可能的 Error。Error 的来源分两种：一种是由于 25 行的
            `Promise.reject`，我们返回 400 状态码及其错误信息；另一种是其他 Mongoose 方法抛出的错误，我们就通过
            `next` 将错误传递给 express 的 [Error
            Handler](http://www.expressjs.com.cn/guide/error-handling.html)。
      - file: package-lock.json
      - file: tuture.yml
    explain:
      pre: 我们先实现注册端口。
      post: >-
        我们用 curl 来测试一下刚才写的 signup 端口：


        ```bash

        $ curl -H "Content-Type: application/json" -X POST -d
        '{"username":"xyz","password":"xyz"}' localhost:3000/signup

        注册成功！

        ```


        再执行一下同样的命令（尝试用同样的用户名注册）：


        ```bash

        $ curl -H "Content-Type: application/json" -X POST -d
        '{"username":"xyz","password":"xyz"}' localhost:3000/signup

        用户名已经被注册！

        ```


        如果你习惯用 Postman 的话，当然也可以试试看哦！
  - name: 实现登录端口
    commit: fd2d14d
    diff:
      - file: models/User.js
        display: true
        explain:
          pre: 我们为 `User` 模型添加一个实例方法 `comparePassword`，用于判断所提供的明文密码是否和被加密过的密码是相同的：
          post: 在后面的数据库查询中，我们就可以调用任一 `User` 实例的 `comparePassword` 方法来判断密码的正确性。
      - file: app.js
        display: true
        explain:
          pre: 接着在 app.js 中添加 POST /login 的路由逻辑：
          post: |-
            与上一步骤相同，我们使用 Promise 的链式调用来处理以下流程：

            1. 在数据库中查询符合指定 `username` 的用户是否存在
            2. 如果用户不存在，结束流程，否则验证密码是否正确
            3. 如果密码正确，返回 200 状态码及成功提示，否则结束流程
      - file: tuture.yml
    explain:
      pre: 我们继续实现登录端口。
      post: >-
        我们继续用 curl （或者 Postman）来验证 /login 端口：


        ```bash

        $ curl -H "Content-Type: application/json" -X POST -d
        '{"username":"test","password":"test"}' localhost:3000/login

        登陆成功！

        $ curl -H "Content-Type: application/json" -X POST -d
        '{"username":"test","password":"foo"}' localhost:3000/login

        密码错误！

        $ curl -H "Content-Type: application/json" -X POST -d
        '{"username":"unknown","password":"unknown"}' localhost:3000/login

        用户名不存在！

        ```


        至此，一个简陋但基本成形的用户系统已经搭建好了。在接下里的教程中，我们将搭建前端页面及相应的会话机制。
